In the start, the buttons will be demonstrated to the player
identify runtime assumptions to test. For example, there might be an assumption to reinforce about the groups of the model after init & the first fight.
in init make a list that will be used to construct grouped_responses and grouped_keys


make "undo" an exception to the auto-save

Progress:
  Timestamp/mistake
  compute progress in presses instead of abstract points
  set minimum

Animation: 
  transition
  menu
  characters in fight
  victory 

Visuals:
  Transparent letter behind each letter to prevent the audio visualizer from hiding them.
  Level selector:
    selected row by gets a grid/area
    fill grid it with selected buttons + reverse button
    update buttons

Input:
  Mod gives a set of inputs that will be excepted to it's entry point (response)
  Single map

Timer:
  Don't store
  Shared logic

Audio: 
  Schedule
  Song:
    stored as a stack of pairs of tracks
    played as a stuck of tracks from the stored stack
    transition:
      temporary response to a stack change
      can be a track or a effect
    a track can be accelerated to a shared maximum as a response to good play

Goal:
 Level selector
 Dynamic ost
 persistent memory

Updates:
  cross platform
  endless levels 
  histogram

Sequel:
  Migrate to Wisp

Quality Assurance:
  Optimization
  
Far future:
  Image: 
    With arrays
    Transparent pixels for non square images
    Pixels pushing each other
    Shot pixels from multiple directions
    Deconstruct to rebuild in reverse
    Support different sizes

game mod: Memory challenge, remember the hidden buttons
Visuals that express the correct io
Color and background picker with payed customization.
